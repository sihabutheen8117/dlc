import cv2
import numpy as np
import matplotlib.pyplot as plt
import urllib.request
import os

def download_yolo_files():
    """Download YOLOv3 model files if not already present"""

    files = {
        'yolov3.weights': 'https://pjreddie.com/media/files/yolov3.weights',
        'yolov3.cfg': 'https://raw.githubusercontent.com/pjreddie/darknet/master/cfg/yolov3.cfg',
        'coco.names': 'https://raw.githubusercontent.com/pjreddie/darknet/master/data/coco.names'
    }

    for filename, url in files.items():
        if not os.path.exists(filename):
            print(f"Downloading {filename}...")
            urllib.request.urlretrieve(url, filename)
            print(f"✓ {filename} downloaded")
        else:
            print(f"✓ {filename} already exists")

    print("\nAll files ready!")

def load_yolo_model():
    """Load YOLOv3 model and class names"""

    # Load YOLO
    net = cv2.dnn.readNet("yolov3.weights", "yolov3.cfg")

    # Load class names
    with open("coco.names", "r") as f:
        classes = [line.strip() for line in f.readlines()]

    # Get layer names
    layer_names = net.getLayerNames()
    output_layers = [layer_names[i - 1] for i in net.getUnconnectedOutLayers()]

    return net, classes, output_layers

def detect_objects(image_path, confidence_threshold=0.5, nms_threshold=0.4):
    """
    Detect objects in an image using YOLOv3

    Args:
        image_path: Path to input image
        confidence_threshold: Minimum confidence to keep detection (0-1)
        nms_threshold: IoU threshold for Non-Maximum Suppression (0-1)

    Returns:
        Image with bounding boxes drawn
    """

    # Load model
    print("Loading YOLO model...")
    net, classes, output_layers = load_yolo_model()

    # Load image
    print(f"Loading image: {image_path}")
    image = cv2.imread(image_path)
    if image is None:
        raise ValueError(f"Could not load image: {image_path}")

    height, width = image.shape[:2]

    # Prepare image for YOLO (create blob)
    blob = cv2.dnn.blobFromImage(
        image,
        scalefactor=1/255.0,  # Normalize to 0-1
        size=(416, 416),       # YOLO input size
        swapRB=True,           # Convert BGR to RGB
        crop=False
    )

    # Run detection
    print("Running detection...")
    net.setInput(blob)
    outputs = net.forward(output_layers)

    # Process detections
    boxes = []
    confidences = []
    class_ids = []

    for output in outputs:
        for detection in output:
            scores = detection[5:]  # Class probabilities
            class_id = np.argmax(scores)
            confidence = scores[class_id]

            if confidence > confidence_threshold:
                # Get box coordinates (YOLO returns center x, y, width, height)
                center_x = int(detection[0] * width)
                center_y = int(detection[1] * height)
                w = int(detection[2] * width)
                h = int(detection[3] * height)

                # Convert to top-left corner coordinates
                x = int(center_x - w / 2)
                y = int(center_y - h / 2)

                boxes.append([x, y, w, h])
                confidences.append(float(confidence))
                class_ids.append(class_id)

    # Apply Non-Maximum Suppression (remove duplicate detections)
    indices = cv2.dnn.NMSBoxes(boxes, confidences, confidence_threshold, nms_threshold)

    # Convert indices to a flat list (handles different OpenCV versions)
    if len(indices) > 0:
        indices = indices.flatten()

    # Print detection summary
    print(f"\nFound {len(indices)} objects:")

    # Draw boxes on image
    colors = np.random.randint(0, 255, size=(len(classes), 3), dtype=np.uint8)

    if len(indices) > 0:
        for i in indices:
            box = boxes[i]
            x, y, w, h = box
            label = str(classes[class_ids[i]])
            confidence = confidences[i]
            color = colors[class_ids[i]].tolist()

            # Print detection info
            print(f"  - {label}: {confidence:.2f}")

            # Draw rectangle
            cv2.rectangle(image, (x, y), (x + w, y + h), color, 2)

            # Draw label background
            text = f"{label} {confidence:.2f}"
            (text_width, text_height), baseline = cv2.getTextSize(
                text, cv2.FONT_HERSHEY_SIMPLEX, 0.5, 2
            )
            cv2.rectangle(
                image,
                (x, y - text_height - 10),
                (x + text_width, y),
                color,
                -1
            )

            # Draw label text
            cv2.putText(
                image,
                text,
                (x, y - 5),
                cv2.FONT_HERSHEY_SIMPLEX,
                0.5,
                (255, 255, 255),
                2
            )

    return image

def display_result(image):
    """Display the image with detections using matplotlib"""

    # Convert BGR to RGB for matplotlib
    image_rgb = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)

    # Display
    plt.figure(figsize=(12, 8))
    plt.imshow(image_rgb)
    plt.axis('off')
    plt.title('YOLOv3 Object Detection Results', fontsize=16)
    plt.tight_layout()
    plt.show()

def main():
    """Main function to run object detection"""

    # Configuration
    IMAGE_PATH = '/content/sample_data/traffic light.jfif'  # ← CHANGE THIS to your image path
    CONFIDENCE = 0.5  # Minimum confidence (0-1)
    NMS_THRESHOLD = 0.4  # IoU threshold for removing duplicates

    print("="*60)
    print("YOLOv3 Object Detection")
    print("="*60)

    # Step 1: Download model files
    download_yolo_files()
    print()

    # Step 2: Run detection
    result_image = detect_objects(IMAGE_PATH, CONFIDENCE, NMS_THRESHOLD)

    # Step 3: Display result
    print("\nDisplaying results...")
    display_result(result_image)

    # Optional: Save result (convert to .jpg if needed)
    base_name = os.path.splitext(os.path.basename(IMAGE_PATH))[0]
    output_path = f'output_{base_name}.jpg'
    cv2.imwrite(output_path, result_image)
    print(f"\nResult saved to: {output_path}")

if __name__ == "__main__":
    main()
